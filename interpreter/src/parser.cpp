/**
 * @file parser.cpp
 * @brief Parser implementation for the Roscript interpreter.
 *
 * This file contains the implementation of the parser for the Roscript interpreter. It includes functions to parse expressions, variable declarations, and error handling.
 * It's header contains the definitions of the AST nodes and the parser functions.
 * @see parser.h
 * 
 * IMPORTANT
 * This is the description of the parse_rhs_expression function, which is the core of the parser. It handles operator precedence and associativity, and recursively parses right-hand side expressions.
 * @image html prhse.png
 *
 * @author Rares-Cosma
 * @date 2025-04-25
 */

#include "parser.h"
#include "commons.cpp"

// wrapper class for the lexer output for easier handling of tokens

/**
 * @class TokenStream
 * @brief A class to handle the tokens generated by the lexer.
 * @note This class is used to store the tokens generated by the lexer and to split them into lines for easier parsing.
 */

class TokenStream {
public:
	vector<pair<string, string>> tokens;
	vector<vector<pair<string, string>>> lines;

	void init() {
		/**
		 * @brief Initializes the TokenStream by splitting the tokens into lines.
		 * @note This function is called after the tokens are generated by the lexer. It splits the tokens into lines based on the "NLINE" token.
		 * @returns Lines vector containing the tokens split into lines.
		 */
		vector<pair<string, string>> line;
		for (const auto& token : tokens) {
			if (token.first == "NLINE") {
				lines.push_back(line);
				line.clear();
			} else {
				line.push_back(token);
			}
		}
		if (!line.empty()) {
			lines.push_back(line);
		}
	}
};

// ABSTRACT SYNTAX TREE IMPLEMEMTATION

vector<ASTNode*> AST; // vector of AST nodes

// PARSER IMPLEMENTATION

int get_precedence(const string& op) {
	if (op == "+" || op == "-") return 1;
	if (op == "*" || op == "/") return 2;
	return 0;
}

Expr* parse_expression(const vector<pair<string, string>>& tokens, int& idx);

Expr* parse_primary_expression(const vector<pair<string, string>>& tokens, int& idx) {

	/**
 	* @brief Parses the simplest elements of an expression (literals and variable references).
 	* @param tokens The tokens to parse.
 	* @param idx The current index in the tokens vector.
 	* @return The coresponding derived expression.
	 */

    if (idx >= tokens.size()) return nullptr;

    if (tokens[idx].first == "INT") {
        int value = stoi(tokens[idx].second);
        idx++;
        return new IntLiteral(value);
    }
    else if (tokens[idx].first == "FLOAT") {
        float value = stof(tokens[idx].second);
        idx++;
        return new FloatLiteral(value);
    }
    else if (tokens[idx].first == "STRING") {
        string value = tokens[idx].second;
        idx++;
        return new StringLiteral(value);
    }
    else if (tokens[idx].first == "ID") {
        string name = tokens[idx].second;
        idx++;
        return new Refrence(name);
    }
	else if (tokens[idx].first == "LPAREN") {
        idx++; // consume (
        Expr* expr = parse_expression(tokens, idx);
        if (idx >= tokens.size() || tokens[idx].first != "RPAREN") {
            cerr << "Error: expected ')' after expression" << endl;
            return nullptr;
        }
        idx++; // consume )
        return expr;
    }
    return nullptr;
}

Expr* parse_rhs_expression(int expr_prec, Expr* lhs, const vector<pair<string, string>>& tokens, int& idx) {
	/**
 	* @brief Parses right-hand expression.
 	* @param expr_prec The current expression precedence.
	* @param lhs The left-hand side expression.
	* @param tokens The tokens to parse.
 	* @param idx The current index in the tokens vector.
	* @note This function is the core to our parser, because it handles the precedence of the operators and the associativity. It is recursive and will call itself to parse the right-hand side expression.
 	* @return BinaryExpr combining the left and right expressions.
	 */

	while (idx < tokens.size()) {
        if (tokens[idx].first != "OP") break;
        string op = tokens[idx].second;
        int prec = get_precedence(op);

        if (prec < expr_prec) break;

        idx++; // consume operator
        Expr* rhs = parse_primary_expression(tokens, idx);
        if (!rhs) return nullptr;

        while (idx < tokens.size() && tokens[idx].first == "OP" &&
               get_precedence(tokens[idx].second) >= prec) {
            rhs = parse_rhs_expression(get_precedence(tokens[idx].second), rhs, tokens, idx);
        }

        lhs = new BinaryExpr(lhs, op, rhs);
    }

    return lhs;
}

Expr* parse_expression(const vector<pair<string, string>>& tokens, int& idx) {
	/**
 	* @brief Parses an expression and returns the corresponding AST node.
 	* @param tokens The tokens to parse.
 	* @param idx The current index in the tokens vector.
 	* @return The parsed expression as an AST node.
	 */
	if (idx >= tokens.size()) return nullptr;
	Expr* left = parse_primary_expression(tokens, idx);
	if (!left) return nullptr;

	return parse_rhs_expression(0, left, tokens, idx);
}

void report_error(const string& msg, const vector<pair<string, string>>& line, int line_nb) {
	/**
 	* @brief Thows custom syntax errors.
 	* @param line The line of the error.
 	* @param line_nb The line number in the source code.
 	* @return Prints the error message and the line of code.
	 */
	cerr << "Syntax Error: " << msg << "\nOn line: ";
	cout << line_nb << ": ";
	for (const auto& token : line) {
		cerr << token.second << " ";
	}
	cerr << "\n\n";
}

void parse_variable_declaration(const vector<pair<string, string>>& line, int line_nb) {
	/**
 	* @brief Parses a variable declaration line.
 	* @param line The line to parse.
 	* @param line_nb The line number in the source code.
 	* @return Adds the variable declaration to the AST.
 	* @note Because "var" is not a type spefcific keyword, we cannot determine the type of the variable, in case it has no initializer so we add it to the NDT stack (non determined) and relocate it later.
	 */

	if (line.size() < 2) {
		report_error("Expected identifier after 'var'", line, line_nb);
		return;
	}

	if (line[1].first != "ID") {
		report_error("Expected variable name after 'var'", line, line_nb);
		return;
	}

	if (line.size() == 2) {
		ASTNode* node = new VariableDeclaration("NDT", line[1].second, nullptr);
		AST.push_back(node);
		return;
	}

	if (line[2].second == "=") {
		if (line.size() > 3) {
			int idx = 3;
			Expr* expr = parse_expression(line, idx);
			
			if (expr) {
				ASTNode* node = new VariableDeclaration("NDT", line[1].second, expr);
				AST.push_back(node);
			} else {
				report_error("Expression parsing failed", line, line_nb);
			}
		} else {
			report_error("Expected initializer after '='", line, line_nb);
		}
	} else {
		report_error("Expected '=' after variable name", line, line_nb);
	}
}

void parse_print_statement(const vector<pair<string, string>>& line, int line_nb) {
	/**
 	* @brief Parses a print statement line.
 	* @param line The line to parse.
 	* @param line_nb The line number in the source code.
 	* @return Adds the print statement to the AST.
	 */

	if (line.size() >= 2) {
		int idx=1;
		ASTNode* node = new PrintStatement(parse_expression(line, idx));
		AST.push_back(node);
		return;
	} else {
		report_error("Expected identifier after 'afiseaza'", line, line_nb);
		return;
	}
}

vector<ASTNode*> parse(vector<pair<string, string>> tokens) {
	/**
 	* @brief Parses the tokens and creates the AST.
 	* @param tokens The tokens to parse.
 	* @return The AST.
 	* @note This function is the main entry point for the parser. It takes the tokens generated by the lexer and creates the AST.
	 */

	TokenStream stream;
	stream.tokens = tokens;
	stream.init();

	int ct = 1; // line number counter

	for (const auto& line : stream.lines) {
		if (line.empty()) continue; // skip empty lines

		const auto& first_token = line[0];
		if (first_token.first == "KEYWORD" && first_token.second == "var") {
			parse_variable_declaration(line, ct); // parse variable declaration
		} else if (first_token.first == "KEYWORD" && first_token.second == "afiseaza") {
			parse_print_statement(line, ct); // parse print statement
		}
		ct++;
	}
	return AST;
}

